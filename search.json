[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": ".",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "reference/meta.html",
    "href": "reference/meta.html",
    "title": "meta",
    "section": "",
    "text": "meta\n\n\n\n\n\nName\nDescription\n\n\n\n\nanno_dict\n__annotation__ dictionary withemptycast toNone, returning empty if doesn't exist | | [delegates](#fastcore.meta.delegates) | Decorator: replacekwargsin signature with params fromto| | [empty2none](#fastcore.meta.empty2none) | ReplaceParameter.emptywithNone| | [funcs_kwargs](#fastcore.meta.funcs_kwargs) | Replace methods incls._methodswith those fromkwargs| | [method](#fastcore.meta.method) | Markfas a method | | [test_sig](#fastcore.meta.test_sig) | Test the signature of an object | | [use_kwargs](#fastcore.meta.use_kwargs) | Decorator: replacekwargsin signature withnamesparams | | [use_kwargs_dict](#fastcore.meta.use_kwargs_dict) | Decorator: replace**kwargsin signature withnames` params\n\n\n\n\n\nmeta.anno_dict(f)\n__annotation__ dictionary withemptycast toNone`, returning empty if doesn’t exist\n\n\n\nmeta.delegates(to=None, keep=False, but=None)\nDecorator: replace **kwargs in signature with params from to\n\n\n\nmeta.empty2none(p)\nReplace Parameter.empty with None\n\n\n\nmeta.funcs_kwargs(as_method=False)\nReplace methods in cls._methods with those from kwargs\n\n\n\nmeta.method(f)\nMark f as a method\n\n\n\nmeta.test_sig(f, b)\nTest the signature of an object\n\n\n\nmeta.use_kwargs(names, keep=False)\nDecorator: replace **kwargs in signature with names params\n\n\n\nmeta.use_kwargs_dict(keep=False, **kwargs)\nDecorator: replace **kwargs in signature with names params"
  },
  {
    "objectID": "reference/meta.html#functions",
    "href": "reference/meta.html#functions",
    "title": "meta",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nanno_dict\n__annotation__ dictionary withemptycast toNone, returning empty if doesn't exist | | [delegates](#fastcore.meta.delegates) | Decorator: replacekwargsin signature with params fromto| | [empty2none](#fastcore.meta.empty2none) | ReplaceParameter.emptywithNone| | [funcs_kwargs](#fastcore.meta.funcs_kwargs) | Replace methods incls._methodswith those fromkwargs| | [method](#fastcore.meta.method) | Markfas a method | | [test_sig](#fastcore.meta.test_sig) | Test the signature of an object | | [use_kwargs](#fastcore.meta.use_kwargs) | Decorator: replacekwargsin signature withnamesparams | | [use_kwargs_dict](#fastcore.meta.use_kwargs_dict) | Decorator: replace**kwargsin signature withnames` params\n\n\n\n\n\nmeta.anno_dict(f)\n__annotation__ dictionary withemptycast toNone`, returning empty if doesn’t exist\n\n\n\nmeta.delegates(to=None, keep=False, but=None)\nDecorator: replace **kwargs in signature with params from to\n\n\n\nmeta.empty2none(p)\nReplace Parameter.empty with None\n\n\n\nmeta.funcs_kwargs(as_method=False)\nReplace methods in cls._methods with those from kwargs\n\n\n\nmeta.method(f)\nMark f as a method\n\n\n\nmeta.test_sig(f, b)\nTest the signature of an object\n\n\n\nmeta.use_kwargs(names, keep=False)\nDecorator: replace **kwargs in signature with names params\n\n\n\nmeta.use_kwargs_dict(keep=False, **kwargs)\nDecorator: replace **kwargs in signature with names params"
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "General purpose utilities.\n\n\n\nbasics\n\n\n\nmeta\n\n\n\n\n\n\n\nUtilities for documentation.\n\n\n\ndocments"
  },
  {
    "objectID": "reference/index.html#general-utilities",
    "href": "reference/index.html#general-utilities",
    "title": "Function reference",
    "section": "",
    "text": "General purpose utilities.\n\n\n\nbasics\n\n\n\nmeta"
  },
  {
    "objectID": "reference/index.html#documentation-utilities",
    "href": "reference/index.html#documentation-utilities",
    "title": "Function reference",
    "section": "",
    "text": "Utilities for documentation.\n\n\n\ndocments"
  },
  {
    "objectID": "reference/utils.html",
    "href": "reference/utils.html",
    "title": "utils",
    "section": "",
    "text": "utils\nutils"
  },
  {
    "objectID": "reference/docments.html",
    "href": "reference/docments.html",
    "title": "docments",
    "section": "",
    "text": "docments\n\n\n\n\n\nName\nDescription\n\n\n\n\nempty\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndocments\nGenerates a docment\n\n\ndocstring\nGet docstring for sym for functions ad classes\n\n\nget_dataclass_source\nGet source code for dataclass s\n\n\nget_name\nGet the name of obj\n\n\nget_source\nGet source code for string, function object or dataclass s\n\n\nisdataclass\nCheck if s is a dataclass but not a dataclass’ instance\n\n\nparse_docstring\nParse a numpy-style docstring in sym\n\n\nqual_name\nGet the qualified name of obj\n\n\n\n\n\ndocments.docments(elt, full=False, **kwargs)\nGenerates a docment\n\n\n\ndocments.docstring(sym)\nGet docstring for sym for functions ad classes\n\n\n\ndocments.get_dataclass_source(s)\nGet source code for dataclass s\n\n\n\ndocments.get_name(obj)\nGet the name of obj\n\n\n\ndocments.get_source(s)\nGet source code for string, function object or dataclass s\n\n\n\ndocments.isdataclass(s)\nCheck if s is a dataclass but not a dataclass’ instance\n\n\n\ndocments.parse_docstring(sym)\nParse a numpy-style docstring in sym\n\n\n\ndocments.qual_name(obj)\nGet the qualified name of obj"
  },
  {
    "objectID": "reference/docments.html#attributes",
    "href": "reference/docments.html#attributes",
    "title": "docments",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nempty"
  },
  {
    "objectID": "reference/docments.html#functions",
    "href": "reference/docments.html#functions",
    "title": "docments",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndocments\nGenerates a docment\n\n\ndocstring\nGet docstring for sym for functions ad classes\n\n\nget_dataclass_source\nGet source code for dataclass s\n\n\nget_name\nGet the name of obj\n\n\nget_source\nGet source code for string, function object or dataclass s\n\n\nisdataclass\nCheck if s is a dataclass but not a dataclass’ instance\n\n\nparse_docstring\nParse a numpy-style docstring in sym\n\n\nqual_name\nGet the qualified name of obj\n\n\n\n\n\ndocments.docments(elt, full=False, **kwargs)\nGenerates a docment\n\n\n\ndocments.docstring(sym)\nGet docstring for sym for functions ad classes\n\n\n\ndocments.get_dataclass_source(s)\nGet source code for dataclass s\n\n\n\ndocments.get_name(obj)\nGet the name of obj\n\n\n\ndocments.get_source(s)\nGet source code for string, function object or dataclass s\n\n\n\ndocments.isdataclass(s)\nCheck if s is a dataclass but not a dataclass’ instance\n\n\n\ndocments.parse_docstring(sym)\nParse a numpy-style docstring in sym\n\n\n\ndocments.qual_name(obj)\nGet the qualified name of obj"
  },
  {
    "objectID": "reference/docscrape.html",
    "href": "reference/docscrape.html",
    "title": "docscrape",
    "section": "",
    "text": "docscrape\nParse numpy-style docstrings\n\n\n\n\n\nName\nDescription\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndedent_lines\nDeindent a list of lines maximally\n\n\nstrip_blank_lines\nRemove leading and trailing blank lines from a list of lines\n\n\n\n\n\ndocscrape.dedent_lines(lines, split=True)\nDeindent a list of lines maximally\n\n\n\ndocscrape.strip_blank_lines(l)\nRemove leading and trailing blank lines from a list of lines"
  },
  {
    "objectID": "reference/docscrape.html#attributes",
    "href": "reference/docscrape.html#attributes",
    "title": "docscrape",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nParameter"
  },
  {
    "objectID": "reference/docscrape.html#functions",
    "href": "reference/docscrape.html#functions",
    "title": "docscrape",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndedent_lines\nDeindent a list of lines maximally\n\n\nstrip_blank_lines\nRemove leading and trailing blank lines from a list of lines\n\n\n\n\n\ndocscrape.dedent_lines(lines, split=True)\nDeindent a list of lines maximally\n\n\n\ndocscrape.strip_blank_lines(l)\nRemove leading and trailing blank lines from a list of lines"
  },
  {
    "objectID": "reference/basics.html",
    "href": "reference/basics.html",
    "title": "basics",
    "section": "",
    "text": "basics\n\n\n\n\n\nName\nDescription\n\n\n\n\nSelf\n\n\n\narg0\n\n\n\narg1\n\n\n\narg2\n\n\n\narg3\n\n\n\narg4\n\n\n\ndefaults\n\n\n\ninum_methods\n\n\n\nnull\n\n\n\nnum_methods\n\n\n\nrnum_methods\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_props\nCreate properties passing each of range(n) to f\n\n\nanno_ret\nGet the return annotation of func\n\n\nannotations\nAnnotations for o, or type(o)\n\n\nargnames\nNames of arguments to function or frame f\n\n\nargwhere\nLike filter_ex, but return indices for matching items\n\n\nattrdict\nDict from each k in ks to getattr(o,k)\n\n\nbasic_repr\nMinimal __repr__\n\n\ncamel2snake\nConvert CamelCase to snake_case\n\n\ncamel2words\nConvert CamelCase to ‘spaced words’\n\n\nchunked\nReturn batches from iterator it of size chunk_sz (or return n_chunks total)\n\n\nclass2attr\nReturn the snake-cased name of the class; strip ending cls_name if it exists.\n\n\ncompile_re\nCompile pat if it’s not None\n\n\ncompose\nCreate a function that composes all functions in funcs, passing along remaining *args and **kwargs to all\n\n\nconcat\nConcatenate all collections and items as a list\n\n\ncopy_func\nCopy a non-builtin function (NB copy.copy does not work for this)\n\n\ncustom_dir\nImplement custom __dir__, adding add to cls\n\n\ncycle\nLike itertools.cycle except creates list of Nones if o is empty\n\n\ndelegate_attr\nUse in __getattr__ to delegate to attr to without inheriting from GetAttr\n\n\ndetuplify\nIf x is a tuple with one thing, extract it\n\n\neval_type\neval a type or collection of types, if needed, for annotations in py3.10+\n\n\neven_mults\nBuild log-stepped array from start to stop in n steps.\n\n\nexec_import\nImport sym from mod in a new environment\n\n\nexec_local\nCall exec on code and return the var var_name\n\n\nexec_new\nExecute code in a new environment and return it\n\n\nfilter_dict\nFilter a dict using func, applied to keys and values\n\n\nfilter_ex\nLike filter, but passing kwargs to f, defaulting f to noop, and adding negate and gen\n\n\nfilter_keys\nFilter a dict using func, applied to keys\n\n\nfilter_values\nFilter a dict using func, applied to values\n\n\nfirst\nFirst element of x, optionally filtered by f, or None if missing\n\n\nflatten\nConcatenate all collections and items as a generator\n\n\ngen\nLike (func(o) for o in seq if cond(func(o))) but handles StopIteration\n\n\nget_annotations_ex\nBackport of py3.10 get_annotations that returns globals/locals\n\n\nget_class\nDynamically create a class, optionally inheriting from sup, containing fld_names\n\n\ngetattrs\nList of all attrs in o\n\n\ngetcallable\nCalls getattr with a default of noop\n\n\ngroupby\nLike itertools.groupby but doesn’t need to be sorted, and isn’t lazy, plus some extensions\n\n\nhasattrs\nTest whether o contains all attrs\n\n\nifnone\nb if a is None else a\n\n\nin_\nTrue if x in a\n\n\ninstantiate\nInstantiate t if it’s a type, otherwise do nothing\n\n\nis_array\nTrue if x supports __array__ or iloc\n\n\nlast_index\nFinds the last index of occurence of x in o (returns -1 if no occurence)\n\n\nlistify\nConvert o to a list\n\n\nloop_first\nIterate and generate a tuple with a flag for first value.\n\n\nloop_first_last\nIterate and generate a tuple with a flag for first and last value.\n\n\nloop_last\nIterate and generate a tuple with a flag for last value.\n\n\nmap_ex\nLike map, but use bind, and supports str and indexing\n\n\nmaps\nLike map, except funcs are composed first\n\n\nmapt\nTuplified map\n\n\nmaybe_attr\ngetattr(o,attr,o)\n\n\nmerge\nMerge all dictionaries in ds\n\n\nmk_class\nCreate a class using get_class and add to the caller’s module\n\n\nnested_attr\nSame as getattr, but if attr includes a ., then looks inside nested objects\n\n\nnested_callable\nSame as nested_attr but if not found will return noop\n\n\nnested_idx\nIndex into nested collections, dicts, etc, with idxs\n\n\nnested_setdefault\nSame as setdefault, but if attr includes a ., then looks inside nested objects\n\n\nnot_\nCreate new function that negates result of f\n\n\nnum_cpus\nGet number of cpus\n\n\nonly\nReturn the only item of o, raise if o doesn’t have exactly one item\n\n\notherwise\ny if tst(x) else x\n\n\npartialler\nLike functools.partial but also copies over docstring\n\n\npatch\nDecorator: add f to the first parameter’s class (based on f’s type annotations)\n\n\npatch_property\nDeprecated; use patch(as_prop=True) instead\n\n\npatch_to\nDecorator: add f to cls\n\n\nproperties\nChange attrs in cls with names in ps to properties\n\n\nrange_of\nAll indices of collection a, if a is a collection, otherwise range\n\n\nrenumerate\nSame as enumerate, but returns index as 2nd element instead of 1st\n\n\nreplicate\nCreate tuple of item copied len(match) times\n\n\nret_false\nPredicate: always False\n\n\nret_true\nPredicate: always True\n\n\nrisinstance\nCurried isinstance but with args reversed\n\n\nset_nested_idx\nSet value indexed like nested_idx | | [setattrs](#fastcore.basics.setattrs) |  | | [setify](#fastcore.basics.setify) | Turn any list like-object into a set. | | [signature_ex](#fastcore.basics.signature_ex) | Backport ofinspect.signature(…, eval_str=Trueto &lt;py310 | | [snake2camel](#fastcore.basics.snake2camel) | Convert snake_case to CamelCase | | [sorted_ex](#fastcore.basics.sorted_ex) | Likesorted, but if key is str useattrgetter; if int useitemgetter| | [stop](#fastcore.basics.stop) | Raises exceptione(by defaultStopException) | | [store_attr](#fastcore.basics.store_attr) | Store params named in comma-separatednamesfrom calling context into attrs inself| | [str2bool](#fastcore.basics.str2bool) | Case-insensitive convert stringstoo a bool (y,yes,t,true,on,1-&gt;True) | | [str_enum](#fastcore.basics.str_enum) | Simplified creation ofStrEnumtypes | | [strcat](#fastcore.basics.strcat) | Concatenate stringified itemsits| | [tonull](#fastcore.basics.tonull) | ConvertNonetonull| | [true](#fastcore.basics.true) | Test whetherxis truthy; collections with &gt;0 elements are consideredTrue| | [try_attrs](#fastcore.basics.try_attrs) | Return first attr that exists inobj| | [tuplify](#fastcore.basics.tuplify) | Makeoa tuple | | [type_hints](#fastcore.basics.type_hints) | Liketyping.get_type_hintsbut returnsif not allowed type | | [typed](#fastcore.basics.typed) | Decorator to check param and return types at runtime | | [union2tuple](#fastcore.basics.union2tuple) |  | | [uniqueify](#fastcore.basics.uniqueify) | Unique elements inx, optionalsort, optional return reverse correspondence, optional prepend with elements. | | [using_attr](#fastcore.basics.using_attr) | Construct a function which appliesfto the argument's attributeattr| | [val2idx](#fastcore.basics.val2idx) | Dict from value to index | | [with_cast](#fastcore.basics.with_cast) | Decorator which uses any parameter annotations as preprocessing functions | | [wrap_class](#fastcore.basics.wrap_class) | Decorator: makes function a method of a new classnmpassing parameters tomk_class| | [zip_cycle](#fastcore.basics.zip_cycle) | Likeitertools.zip_longestbutcycle`s through elements of all but first argument\n\n\n\n\n\nbasics.add_props(f, g=None, n=2)\nCreate properties passing each of range(n) to f\n\n\n\nbasics.anno_ret(func)\nGet the return annotation of func\n\n\n\nbasics.annotations(o)\nAnnotations for o, or type(o)\n\n\n\nbasics.argnames(f, frame=False)\nNames of arguments to function or frame f\n\n\n\nbasics.argwhere(iterable, f, negate=False, **kwargs)\nLike filter_ex, but return indices for matching items\n\n\n\nbasics.attrdict(o, *ks, default=None)\nDict from each k in ks to getattr(o,k)\n\n\n\nbasics.basic_repr(flds=None)\nMinimal __repr__\n\n\n\nbasics.camel2snake(name)\nConvert CamelCase to snake_case\n\n\n\nbasics.camel2words(s, space=' ')\nConvert CamelCase to ‘spaced words’\n\n\n\nbasics.chunked(it, chunk_sz=None, drop_last=False, n_chunks=None)\nReturn batches from iterator it of size chunk_sz (or return n_chunks total)\n\n\n\nbasics.class2attr(self, cls_name)\nReturn the snake-cased name of the class; strip ending cls_name if it exists.\n\n\n\nbasics.compile_re(pat)\nCompile pat if it’s not None\n\n\n\nbasics.compose(*funcs, order=None)\nCreate a function that composes all functions in funcs, passing along remaining *args and **kwargs to all\n\n\n\nbasics.concat(colls)\nConcatenate all collections and items as a list\n\n\n\nbasics.copy_func(f)\nCopy a non-builtin function (NB copy.copy does not work for this)\n\n\n\nbasics.custom_dir(c, add)\nImplement custom __dir__, adding add to cls\n\n\n\nbasics.cycle(o)\nLike itertools.cycle except creates list of Nones if o is empty\n\n\n\nbasics.delegate_attr(self, k, to)\nUse in __getattr__ to delegate to attr to without inheriting from GetAttr\n\n\n\nbasics.detuplify(x)\nIf x is a tuple with one thing, extract it\n\n\n\nbasics.eval_type(t, glb, loc)\neval a type or collection of types, if needed, for annotations in py3.10+\n\n\n\nbasics.even_mults(start, stop, n)\nBuild log-stepped array from start to stop in n steps.\n\n\n\nbasics.exec_import(mod, sym)\nImport sym from mod in a new environment\n\n\n\nbasics.exec_local(code, var_name)\nCall exec on code and return the var var_name\n\n\n\nbasics.exec_new(code)\nExecute code in a new environment and return it\n\n\n\nbasics.filter_dict(d, func)\nFilter a dict using func, applied to keys and values\n\n\n\nbasics.filter_ex(iterable, f=noop, negate=False, gen=False, **kwargs)\nLike filter, but passing kwargs to f, defaulting f to noop, and adding negate and gen\n\n\n\nbasics.filter_keys(d, func)\nFilter a dict using func, applied to keys\n\n\n\nbasics.filter_values(d, func)\nFilter a dict using func, applied to values\n\n\n\nbasics.first(x, f=None, negate=False, **kwargs)\nFirst element of x, optionally filtered by f, or None if missing\n\n\n\nbasics.flatten(o)\nConcatenate all collections and items as a generator\n\n\n\nbasics.gen(func, seq, cond=ret_true)\nLike (func(o) for o in seq if cond(func(o))) but handles StopIteration\n\n\n\nbasics.get_annotations_ex(obj, *, globals=None, locals=None)\nBackport of py3.10 get_annotations that returns globals/locals\n\n\n\nbasics.get_class(nm, *fld_names, sup=None, doc=None, funcs=None, **flds)\nDynamically create a class, optionally inheriting from sup, containing fld_names\n\n\n\nbasics.getattrs(o, *attrs, default=None)\nList of all attrs in o\n\n\n\nbasics.getcallable(o, attr)\nCalls getattr with a default of noop\n\n\n\nbasics.groupby(x, key, val=noop)\nLike itertools.groupby but doesn’t need to be sorted, and isn’t lazy, plus some extensions\n\n\n\nbasics.hasattrs(o, attrs)\nTest whether o contains all attrs\n\n\n\nbasics.ifnone(a, b)\nb if a is None else a\n\n\n\nbasics.in_(x, a)\nTrue if x in a\n\n\n\nbasics.instantiate(t)\nInstantiate t if it’s a type, otherwise do nothing\n\n\n\nbasics.is_array(x)\nTrue if x supports __array__ or iloc\n\n\n\nbasics.last_index(x, o)\nFinds the last index of occurence of x in o (returns -1 if no occurence)\n\n\n\nbasics.listify(o=None, *rest, use_list=False, match=None)\nConvert o to a list\n\n\n\nbasics.loop_first(values)\nIterate and generate a tuple with a flag for first value.\n\n\n\nbasics.loop_first_last(values)\nIterate and generate a tuple with a flag for first and last value.\n\n\n\nbasics.loop_last(values)\nIterate and generate a tuple with a flag for last value.\n\n\n\nbasics.map_ex(iterable, f, *args, gen=False, **kwargs)\nLike map, but use bind, and supports str and indexing\n\n\n\nbasics.maps(*args, retain=noop)\nLike map, except funcs are composed first\n\n\n\nbasics.mapt(func, *iterables)\nTuplified map\n\n\n\nbasics.maybe_attr(o, attr)\ngetattr(o,attr,o)\n\n\n\nbasics.merge(*ds)\nMerge all dictionaries in ds\n\n\n\nbasics.mk_class(nm, *fld_names, sup=None, doc=None, funcs=None, mod=None, **flds)\nCreate a class using get_class and add to the caller’s module\n\n\n\nbasics.nested_attr(o, attr, default=None)\nSame as getattr, but if attr includes a ., then looks inside nested objects\n\n\n\nbasics.nested_callable(o, attr)\nSame as nested_attr but if not found will return noop\n\n\n\nbasics.nested_idx(coll, *idxs)\nIndex into nested collections, dicts, etc, with idxs\n\n\n\nbasics.nested_setdefault(o, attr, default)\nSame as setdefault, but if attr includes a ., then looks inside nested objects\n\n\n\nbasics.not_(f)\nCreate new function that negates result of f\n\n\n\nbasics.num_cpus()\nGet number of cpus\n\n\n\nbasics.only(o)\nReturn the only item of o, raise if o doesn’t have exactly one item\n\n\n\nbasics.otherwise(x, tst, y)\ny if tst(x) else x\n\n\n\nbasics.partialler(f, *args, order=None, **kwargs)\nLike functools.partial but also copies over docstring\n\n\n\nbasics.patch(f=None, *, as_prop=False, cls_method=False)\nDecorator: add f to the first parameter’s class (based on f’s type annotations)\n\n\n\nbasics.patch_property(f)\nDeprecated; use patch(as_prop=True) instead\n\n\n\nbasics.patch_to(cls, as_prop=False, cls_method=False)\nDecorator: add f to cls\n\n\n\nbasics.properties(cls, *ps)\nChange attrs in cls with names in ps to properties\n\n\n\nbasics.range_of(a, b=None, step=None)\nAll indices of collection a, if a is a collection, otherwise range\n\n\n\nbasics.renumerate(iterable, start=0)\nSame as enumerate, but returns index as 2nd element instead of 1st\n\n\n\nbasics.replicate(item, match)\nCreate tuple of item copied len(match) times\n\n\n\nbasics.ret_false(*args, **kwargs)\nPredicate: always False\n\n\n\nbasics.ret_true(*args, **kwargs)\nPredicate: always True\n\n\n\nbasics.risinstance(types, obj=None)\nCurried isinstance but with args reversed\n\n\n\nbasics.set_nested_idx(coll, value, *idxs)\nSet value indexed like `nested_idx\n\n\n\nbasics.setattrs(dest, flds, src)\n\n\n\nbasics.setify(o)\nTurn any list like-object into a set.\n\n\n\nbasics.signature_ex(obj, eval_str=False)\nBackport of inspect.signature(..., eval_str=True to &lt;py310\n\n\n\nbasics.snake2camel(s)\nConvert snake_case to CamelCase\n\n\n\nbasics.sorted_ex(iterable, key=None, reverse=False)\nLike sorted, but if key is str use attrgetter; if int use itemgetter\n\n\n\nbasics.stop(e=StopIteration)\nRaises exception e (by default StopException)\n\n\n\nbasics.store_attr(names=None, self=None, but='', cast=False, store_args=None, **attrs)\nStore params named in comma-separated names from calling context into attrs in self\n\n\n\nbasics.str2bool(s)\nCase-insensitive convert string s too a bool (y,yes,t,true,on,1-&gt;True)\n\n\n\nbasics.str_enum(name, *vals)\nSimplified creation of StrEnum types\n\n\n\nbasics.strcat(its, sep='')\nConcatenate stringified items its\n\n\n\nbasics.tonull(x)\nConvert None to null\n\n\n\nbasics.true(x)\nTest whether x is truthy; collections with &gt;0 elements are considered True\n\n\n\nbasics.try_attrs(obj, *attrs)\nReturn first attr that exists in obj\n\n\n\nbasics.tuplify(o, use_list=False, match=None)\nMake o a tuple\n\n\n\nbasics.type_hints(f)\nLike typing.get_type_hints but returns {} if not allowed type\n\n\n\nbasics.typed(f)\nDecorator to check param and return types at runtime\n\n\n\nbasics.union2tuple(t)\n\n\n\nbasics.uniqueify(x, sort=False, bidir=False, start=None)\nUnique elements in x, optional sort, optional return reverse correspondence, optional prepend with elements.\n\n\n\nbasics.using_attr(f, attr)\nConstruct a function which applies f to the argument’s attribute attr\n\n\n\nbasics.val2idx(x)\nDict from value to index\n\n\n\nbasics.with_cast(f)\nDecorator which uses any parameter annotations as preprocessing functions\n\n\n\nbasics.wrap_class(nm, *fld_names, sup=None, doc=None, funcs=None, **flds)\nDecorator: makes function a method of a new class nm passing parameters to mk_class\n\n\n\nbasics.zip_cycle(x, *args)\nLike itertools.zip_longest but cycles through elements of all but first argument"
  },
  {
    "objectID": "reference/basics.html#attributes",
    "href": "reference/basics.html#attributes",
    "title": "basics",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nSelf\n\n\n\narg0\n\n\n\narg1\n\n\n\narg2\n\n\n\narg3\n\n\n\narg4\n\n\n\ndefaults\n\n\n\ninum_methods\n\n\n\nnull\n\n\n\nnum_methods\n\n\n\nrnum_methods"
  },
  {
    "objectID": "reference/basics.html#functions",
    "href": "reference/basics.html#functions",
    "title": "basics",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadd_props\nCreate properties passing each of range(n) to f\n\n\nanno_ret\nGet the return annotation of func\n\n\nannotations\nAnnotations for o, or type(o)\n\n\nargnames\nNames of arguments to function or frame f\n\n\nargwhere\nLike filter_ex, but return indices for matching items\n\n\nattrdict\nDict from each k in ks to getattr(o,k)\n\n\nbasic_repr\nMinimal __repr__\n\n\ncamel2snake\nConvert CamelCase to snake_case\n\n\ncamel2words\nConvert CamelCase to ‘spaced words’\n\n\nchunked\nReturn batches from iterator it of size chunk_sz (or return n_chunks total)\n\n\nclass2attr\nReturn the snake-cased name of the class; strip ending cls_name if it exists.\n\n\ncompile_re\nCompile pat if it’s not None\n\n\ncompose\nCreate a function that composes all functions in funcs, passing along remaining *args and **kwargs to all\n\n\nconcat\nConcatenate all collections and items as a list\n\n\ncopy_func\nCopy a non-builtin function (NB copy.copy does not work for this)\n\n\ncustom_dir\nImplement custom __dir__, adding add to cls\n\n\ncycle\nLike itertools.cycle except creates list of Nones if o is empty\n\n\ndelegate_attr\nUse in __getattr__ to delegate to attr to without inheriting from GetAttr\n\n\ndetuplify\nIf x is a tuple with one thing, extract it\n\n\neval_type\neval a type or collection of types, if needed, for annotations in py3.10+\n\n\neven_mults\nBuild log-stepped array from start to stop in n steps.\n\n\nexec_import\nImport sym from mod in a new environment\n\n\nexec_local\nCall exec on code and return the var var_name\n\n\nexec_new\nExecute code in a new environment and return it\n\n\nfilter_dict\nFilter a dict using func, applied to keys and values\n\n\nfilter_ex\nLike filter, but passing kwargs to f, defaulting f to noop, and adding negate and gen\n\n\nfilter_keys\nFilter a dict using func, applied to keys\n\n\nfilter_values\nFilter a dict using func, applied to values\n\n\nfirst\nFirst element of x, optionally filtered by f, or None if missing\n\n\nflatten\nConcatenate all collections and items as a generator\n\n\ngen\nLike (func(o) for o in seq if cond(func(o))) but handles StopIteration\n\n\nget_annotations_ex\nBackport of py3.10 get_annotations that returns globals/locals\n\n\nget_class\nDynamically create a class, optionally inheriting from sup, containing fld_names\n\n\ngetattrs\nList of all attrs in o\n\n\ngetcallable\nCalls getattr with a default of noop\n\n\ngroupby\nLike itertools.groupby but doesn’t need to be sorted, and isn’t lazy, plus some extensions\n\n\nhasattrs\nTest whether o contains all attrs\n\n\nifnone\nb if a is None else a\n\n\nin_\nTrue if x in a\n\n\ninstantiate\nInstantiate t if it’s a type, otherwise do nothing\n\n\nis_array\nTrue if x supports __array__ or iloc\n\n\nlast_index\nFinds the last index of occurence of x in o (returns -1 if no occurence)\n\n\nlistify\nConvert o to a list\n\n\nloop_first\nIterate and generate a tuple with a flag for first value.\n\n\nloop_first_last\nIterate and generate a tuple with a flag for first and last value.\n\n\nloop_last\nIterate and generate a tuple with a flag for last value.\n\n\nmap_ex\nLike map, but use bind, and supports str and indexing\n\n\nmaps\nLike map, except funcs are composed first\n\n\nmapt\nTuplified map\n\n\nmaybe_attr\ngetattr(o,attr,o)\n\n\nmerge\nMerge all dictionaries in ds\n\n\nmk_class\nCreate a class using get_class and add to the caller’s module\n\n\nnested_attr\nSame as getattr, but if attr includes a ., then looks inside nested objects\n\n\nnested_callable\nSame as nested_attr but if not found will return noop\n\n\nnested_idx\nIndex into nested collections, dicts, etc, with idxs\n\n\nnested_setdefault\nSame as setdefault, but if attr includes a ., then looks inside nested objects\n\n\nnot_\nCreate new function that negates result of f\n\n\nnum_cpus\nGet number of cpus\n\n\nonly\nReturn the only item of o, raise if o doesn’t have exactly one item\n\n\notherwise\ny if tst(x) else x\n\n\npartialler\nLike functools.partial but also copies over docstring\n\n\npatch\nDecorator: add f to the first parameter’s class (based on f’s type annotations)\n\n\npatch_property\nDeprecated; use patch(as_prop=True) instead\n\n\npatch_to\nDecorator: add f to cls\n\n\nproperties\nChange attrs in cls with names in ps to properties\n\n\nrange_of\nAll indices of collection a, if a is a collection, otherwise range\n\n\nrenumerate\nSame as enumerate, but returns index as 2nd element instead of 1st\n\n\nreplicate\nCreate tuple of item copied len(match) times\n\n\nret_false\nPredicate: always False\n\n\nret_true\nPredicate: always True\n\n\nrisinstance\nCurried isinstance but with args reversed\n\n\nset_nested_idx\nSet value indexed like nested_idx | | [setattrs](#fastcore.basics.setattrs) |  | | [setify](#fastcore.basics.setify) | Turn any list like-object into a set. | | [signature_ex](#fastcore.basics.signature_ex) | Backport ofinspect.signature(…, eval_str=Trueto &lt;py310 | | [snake2camel](#fastcore.basics.snake2camel) | Convert snake_case to CamelCase | | [sorted_ex](#fastcore.basics.sorted_ex) | Likesorted, but if key is str useattrgetter; if int useitemgetter| | [stop](#fastcore.basics.stop) | Raises exceptione(by defaultStopException) | | [store_attr](#fastcore.basics.store_attr) | Store params named in comma-separatednamesfrom calling context into attrs inself| | [str2bool](#fastcore.basics.str2bool) | Case-insensitive convert stringstoo a bool (y,yes,t,true,on,1-&gt;True) | | [str_enum](#fastcore.basics.str_enum) | Simplified creation ofStrEnumtypes | | [strcat](#fastcore.basics.strcat) | Concatenate stringified itemsits| | [tonull](#fastcore.basics.tonull) | ConvertNonetonull| | [true](#fastcore.basics.true) | Test whetherxis truthy; collections with &gt;0 elements are consideredTrue| | [try_attrs](#fastcore.basics.try_attrs) | Return first attr that exists inobj| | [tuplify](#fastcore.basics.tuplify) | Makeoa tuple | | [type_hints](#fastcore.basics.type_hints) | Liketyping.get_type_hintsbut returnsif not allowed type | | [typed](#fastcore.basics.typed) | Decorator to check param and return types at runtime | | [union2tuple](#fastcore.basics.union2tuple) |  | | [uniqueify](#fastcore.basics.uniqueify) | Unique elements inx, optionalsort, optional return reverse correspondence, optional prepend with elements. | | [using_attr](#fastcore.basics.using_attr) | Construct a function which appliesfto the argument's attributeattr| | [val2idx](#fastcore.basics.val2idx) | Dict from value to index | | [with_cast](#fastcore.basics.with_cast) | Decorator which uses any parameter annotations as preprocessing functions | | [wrap_class](#fastcore.basics.wrap_class) | Decorator: makes function a method of a new classnmpassing parameters tomk_class| | [zip_cycle](#fastcore.basics.zip_cycle) | Likeitertools.zip_longestbutcycle`s through elements of all but first argument\n\n\n\n\n\nbasics.add_props(f, g=None, n=2)\nCreate properties passing each of range(n) to f\n\n\n\nbasics.anno_ret(func)\nGet the return annotation of func\n\n\n\nbasics.annotations(o)\nAnnotations for o, or type(o)\n\n\n\nbasics.argnames(f, frame=False)\nNames of arguments to function or frame f\n\n\n\nbasics.argwhere(iterable, f, negate=False, **kwargs)\nLike filter_ex, but return indices for matching items\n\n\n\nbasics.attrdict(o, *ks, default=None)\nDict from each k in ks to getattr(o,k)\n\n\n\nbasics.basic_repr(flds=None)\nMinimal __repr__\n\n\n\nbasics.camel2snake(name)\nConvert CamelCase to snake_case\n\n\n\nbasics.camel2words(s, space=' ')\nConvert CamelCase to ‘spaced words’\n\n\n\nbasics.chunked(it, chunk_sz=None, drop_last=False, n_chunks=None)\nReturn batches from iterator it of size chunk_sz (or return n_chunks total)\n\n\n\nbasics.class2attr(self, cls_name)\nReturn the snake-cased name of the class; strip ending cls_name if it exists.\n\n\n\nbasics.compile_re(pat)\nCompile pat if it’s not None\n\n\n\nbasics.compose(*funcs, order=None)\nCreate a function that composes all functions in funcs, passing along remaining *args and **kwargs to all\n\n\n\nbasics.concat(colls)\nConcatenate all collections and items as a list\n\n\n\nbasics.copy_func(f)\nCopy a non-builtin function (NB copy.copy does not work for this)\n\n\n\nbasics.custom_dir(c, add)\nImplement custom __dir__, adding add to cls\n\n\n\nbasics.cycle(o)\nLike itertools.cycle except creates list of Nones if o is empty\n\n\n\nbasics.delegate_attr(self, k, to)\nUse in __getattr__ to delegate to attr to without inheriting from GetAttr\n\n\n\nbasics.detuplify(x)\nIf x is a tuple with one thing, extract it\n\n\n\nbasics.eval_type(t, glb, loc)\neval a type or collection of types, if needed, for annotations in py3.10+\n\n\n\nbasics.even_mults(start, stop, n)\nBuild log-stepped array from start to stop in n steps.\n\n\n\nbasics.exec_import(mod, sym)\nImport sym from mod in a new environment\n\n\n\nbasics.exec_local(code, var_name)\nCall exec on code and return the var var_name\n\n\n\nbasics.exec_new(code)\nExecute code in a new environment and return it\n\n\n\nbasics.filter_dict(d, func)\nFilter a dict using func, applied to keys and values\n\n\n\nbasics.filter_ex(iterable, f=noop, negate=False, gen=False, **kwargs)\nLike filter, but passing kwargs to f, defaulting f to noop, and adding negate and gen\n\n\n\nbasics.filter_keys(d, func)\nFilter a dict using func, applied to keys\n\n\n\nbasics.filter_values(d, func)\nFilter a dict using func, applied to values\n\n\n\nbasics.first(x, f=None, negate=False, **kwargs)\nFirst element of x, optionally filtered by f, or None if missing\n\n\n\nbasics.flatten(o)\nConcatenate all collections and items as a generator\n\n\n\nbasics.gen(func, seq, cond=ret_true)\nLike (func(o) for o in seq if cond(func(o))) but handles StopIteration\n\n\n\nbasics.get_annotations_ex(obj, *, globals=None, locals=None)\nBackport of py3.10 get_annotations that returns globals/locals\n\n\n\nbasics.get_class(nm, *fld_names, sup=None, doc=None, funcs=None, **flds)\nDynamically create a class, optionally inheriting from sup, containing fld_names\n\n\n\nbasics.getattrs(o, *attrs, default=None)\nList of all attrs in o\n\n\n\nbasics.getcallable(o, attr)\nCalls getattr with a default of noop\n\n\n\nbasics.groupby(x, key, val=noop)\nLike itertools.groupby but doesn’t need to be sorted, and isn’t lazy, plus some extensions\n\n\n\nbasics.hasattrs(o, attrs)\nTest whether o contains all attrs\n\n\n\nbasics.ifnone(a, b)\nb if a is None else a\n\n\n\nbasics.in_(x, a)\nTrue if x in a\n\n\n\nbasics.instantiate(t)\nInstantiate t if it’s a type, otherwise do nothing\n\n\n\nbasics.is_array(x)\nTrue if x supports __array__ or iloc\n\n\n\nbasics.last_index(x, o)\nFinds the last index of occurence of x in o (returns -1 if no occurence)\n\n\n\nbasics.listify(o=None, *rest, use_list=False, match=None)\nConvert o to a list\n\n\n\nbasics.loop_first(values)\nIterate and generate a tuple with a flag for first value.\n\n\n\nbasics.loop_first_last(values)\nIterate and generate a tuple with a flag for first and last value.\n\n\n\nbasics.loop_last(values)\nIterate and generate a tuple with a flag for last value.\n\n\n\nbasics.map_ex(iterable, f, *args, gen=False, **kwargs)\nLike map, but use bind, and supports str and indexing\n\n\n\nbasics.maps(*args, retain=noop)\nLike map, except funcs are composed first\n\n\n\nbasics.mapt(func, *iterables)\nTuplified map\n\n\n\nbasics.maybe_attr(o, attr)\ngetattr(o,attr,o)\n\n\n\nbasics.merge(*ds)\nMerge all dictionaries in ds\n\n\n\nbasics.mk_class(nm, *fld_names, sup=None, doc=None, funcs=None, mod=None, **flds)\nCreate a class using get_class and add to the caller’s module\n\n\n\nbasics.nested_attr(o, attr, default=None)\nSame as getattr, but if attr includes a ., then looks inside nested objects\n\n\n\nbasics.nested_callable(o, attr)\nSame as nested_attr but if not found will return noop\n\n\n\nbasics.nested_idx(coll, *idxs)\nIndex into nested collections, dicts, etc, with idxs\n\n\n\nbasics.nested_setdefault(o, attr, default)\nSame as setdefault, but if attr includes a ., then looks inside nested objects\n\n\n\nbasics.not_(f)\nCreate new function that negates result of f\n\n\n\nbasics.num_cpus()\nGet number of cpus\n\n\n\nbasics.only(o)\nReturn the only item of o, raise if o doesn’t have exactly one item\n\n\n\nbasics.otherwise(x, tst, y)\ny if tst(x) else x\n\n\n\nbasics.partialler(f, *args, order=None, **kwargs)\nLike functools.partial but also copies over docstring\n\n\n\nbasics.patch(f=None, *, as_prop=False, cls_method=False)\nDecorator: add f to the first parameter’s class (based on f’s type annotations)\n\n\n\nbasics.patch_property(f)\nDeprecated; use patch(as_prop=True) instead\n\n\n\nbasics.patch_to(cls, as_prop=False, cls_method=False)\nDecorator: add f to cls\n\n\n\nbasics.properties(cls, *ps)\nChange attrs in cls with names in ps to properties\n\n\n\nbasics.range_of(a, b=None, step=None)\nAll indices of collection a, if a is a collection, otherwise range\n\n\n\nbasics.renumerate(iterable, start=0)\nSame as enumerate, but returns index as 2nd element instead of 1st\n\n\n\nbasics.replicate(item, match)\nCreate tuple of item copied len(match) times\n\n\n\nbasics.ret_false(*args, **kwargs)\nPredicate: always False\n\n\n\nbasics.ret_true(*args, **kwargs)\nPredicate: always True\n\n\n\nbasics.risinstance(types, obj=None)\nCurried isinstance but with args reversed\n\n\n\nbasics.set_nested_idx(coll, value, *idxs)\nSet value indexed like `nested_idx\n\n\n\nbasics.setattrs(dest, flds, src)\n\n\n\nbasics.setify(o)\nTurn any list like-object into a set.\n\n\n\nbasics.signature_ex(obj, eval_str=False)\nBackport of inspect.signature(..., eval_str=True to &lt;py310\n\n\n\nbasics.snake2camel(s)\nConvert snake_case to CamelCase\n\n\n\nbasics.sorted_ex(iterable, key=None, reverse=False)\nLike sorted, but if key is str use attrgetter; if int use itemgetter\n\n\n\nbasics.stop(e=StopIteration)\nRaises exception e (by default StopException)\n\n\n\nbasics.store_attr(names=None, self=None, but='', cast=False, store_args=None, **attrs)\nStore params named in comma-separated names from calling context into attrs in self\n\n\n\nbasics.str2bool(s)\nCase-insensitive convert string s too a bool (y,yes,t,true,on,1-&gt;True)\n\n\n\nbasics.str_enum(name, *vals)\nSimplified creation of StrEnum types\n\n\n\nbasics.strcat(its, sep='')\nConcatenate stringified items its\n\n\n\nbasics.tonull(x)\nConvert None to null\n\n\n\nbasics.true(x)\nTest whether x is truthy; collections with &gt;0 elements are considered True\n\n\n\nbasics.try_attrs(obj, *attrs)\nReturn first attr that exists in obj\n\n\n\nbasics.tuplify(o, use_list=False, match=None)\nMake o a tuple\n\n\n\nbasics.type_hints(f)\nLike typing.get_type_hints but returns {} if not allowed type\n\n\n\nbasics.typed(f)\nDecorator to check param and return types at runtime\n\n\n\nbasics.union2tuple(t)\n\n\n\nbasics.uniqueify(x, sort=False, bidir=False, start=None)\nUnique elements in x, optional sort, optional return reverse correspondence, optional prepend with elements.\n\n\n\nbasics.using_attr(f, attr)\nConstruct a function which applies f to the argument’s attribute attr\n\n\n\nbasics.val2idx(x)\nDict from value to index\n\n\n\nbasics.with_cast(f)\nDecorator which uses any parameter annotations as preprocessing functions\n\n\n\nbasics.wrap_class(nm, *fld_names, sup=None, doc=None, funcs=None, **flds)\nDecorator: makes function a method of a new class nm passing parameters to mk_class\n\n\n\nbasics.zip_cycle(x, *args)\nLike itertools.zip_longest but cycles through elements of all but first argument"
  }
]