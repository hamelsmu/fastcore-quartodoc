[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": ".",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "reference/meta.html",
    "href": "reference/meta.html",
    "title": "meta",
    "section": "",
    "text": "meta\n\n\n\n\n\nName\nDescription\n\n\n\n\nanno_dict\n__annotation__ dictionary withemptycast toNone, returning empty if doesn't exist | | [delegates](#fastcore.meta.delegates) | Decorator: replacekwargsin signature with params fromto| | [empty2none](#fastcore.meta.empty2none) | ReplaceParameter.emptywithNone| | [funcs_kwargs](#fastcore.meta.funcs_kwargs) | Replace methods incls._methodswith those fromkwargs| | [method](#fastcore.meta.method) | Markfas a method | | [test_sig](#fastcore.meta.test_sig) | Test the signature of an object | | [use_kwargs](#fastcore.meta.use_kwargs) | Decorator: replacekwargsin signature withnamesparams | | [use_kwargs_dict](#fastcore.meta.use_kwargs_dict) | Decorator: replace**kwargsin signature withnames` params\n\n\n\n\n\nmeta.anno_dict(f)\n__annotation__ dictionary withemptycast toNone`, returning empty if doesn’t exist\n\n\n\nmeta.delegates(to=None, keep=False, but=None)\nDecorator: replace **kwargs in signature with params from to\n\n\n\nmeta.empty2none(p)\nReplace Parameter.empty with None\n\n\n\nmeta.funcs_kwargs(as_method=False)\nReplace methods in cls._methods with those from kwargs\n\n\n\nmeta.method(f)\nMark f as a method\n\n\n\nmeta.test_sig(f, b)\nTest the signature of an object\n\n\n\nmeta.use_kwargs(names, keep=False)\nDecorator: replace **kwargs in signature with names params\n\n\n\nmeta.use_kwargs_dict(keep=False, **kwargs)\nDecorator: replace **kwargs in signature with names params"
  },
  {
    "objectID": "reference/meta.html#functions",
    "href": "reference/meta.html#functions",
    "title": "meta",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nanno_dict\n__annotation__ dictionary withemptycast toNone, returning empty if doesn't exist | | [delegates](#fastcore.meta.delegates) | Decorator: replacekwargsin signature with params fromto| | [empty2none](#fastcore.meta.empty2none) | ReplaceParameter.emptywithNone| | [funcs_kwargs](#fastcore.meta.funcs_kwargs) | Replace methods incls._methodswith those fromkwargs| | [method](#fastcore.meta.method) | Markfas a method | | [test_sig](#fastcore.meta.test_sig) | Test the signature of an object | | [use_kwargs](#fastcore.meta.use_kwargs) | Decorator: replacekwargsin signature withnamesparams | | [use_kwargs_dict](#fastcore.meta.use_kwargs_dict) | Decorator: replace**kwargsin signature withnames` params\n\n\n\n\n\nmeta.anno_dict(f)\n__annotation__ dictionary withemptycast toNone`, returning empty if doesn’t exist\n\n\n\nmeta.delegates(to=None, keep=False, but=None)\nDecorator: replace **kwargs in signature with params from to\n\n\n\nmeta.empty2none(p)\nReplace Parameter.empty with None\n\n\n\nmeta.funcs_kwargs(as_method=False)\nReplace methods in cls._methods with those from kwargs\n\n\n\nmeta.method(f)\nMark f as a method\n\n\n\nmeta.test_sig(f, b)\nTest the signature of an object\n\n\n\nmeta.use_kwargs(names, keep=False)\nDecorator: replace **kwargs in signature with names params\n\n\n\nmeta.use_kwargs_dict(keep=False, **kwargs)\nDecorator: replace **kwargs in signature with names params"
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "General purpose utilities.\n\n\n\nbasics\n\n\n\nmeta\n\n\n\nutils\n\n\n\n\n\n\n\nUtilities for documentation.\n\n\n\ndocments\n\n\n\ndocscrape\nParse numpy-style docstrings"
  },
  {
    "objectID": "reference/index.html#general-utilities",
    "href": "reference/index.html#general-utilities",
    "title": "Function reference",
    "section": "",
    "text": "General purpose utilities.\n\n\n\nbasics\n\n\n\nmeta\n\n\n\nutils"
  },
  {
    "objectID": "reference/index.html#documentation-utilities",
    "href": "reference/index.html#documentation-utilities",
    "title": "Function reference",
    "section": "",
    "text": "Utilities for documentation.\n\n\n\ndocments\n\n\n\ndocscrape\nParse numpy-style docstrings"
  },
  {
    "objectID": "reference/utils.html",
    "href": "reference/utils.html",
    "title": "utils",
    "section": "",
    "text": "utils\nutils"
  },
  {
    "objectID": "reference/docments.html",
    "href": "reference/docments.html",
    "title": "docments",
    "section": "",
    "text": "docments\n\n\n\n\n\nName\nDescription\n\n\n\n\nempty\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndocments\nGenerates a docment\n\n\ndocstring\nGet docstring for sym for functions ad classes\n\n\nget_dataclass_source\nGet source code for dataclass s\n\n\nget_name\nGet the name of obj\n\n\nget_source\nGet source code for string, function object or dataclass s\n\n\nisdataclass\nCheck if s is a dataclass but not a dataclass’ instance\n\n\nparse_docstring\nParse a numpy-style docstring in sym\n\n\nqual_name\nGet the qualified name of obj\n\n\n\n\n\ndocments.docments(elt, full=False, **kwargs)\nGenerates a docment\n\n\n\ndocments.docstring(sym)\nGet docstring for sym for functions ad classes\n\n\n\ndocments.get_dataclass_source(s)\nGet source code for dataclass s\n\n\n\ndocments.get_name(obj)\nGet the name of obj\n\n\n\ndocments.get_source(s)\nGet source code for string, function object or dataclass s\n\n\n\ndocments.isdataclass(s)\nCheck if s is a dataclass but not a dataclass’ instance\n\n\n\ndocments.parse_docstring(sym)\nParse a numpy-style docstring in sym\n\n\n\ndocments.qual_name(obj)\nGet the qualified name of obj"
  },
  {
    "objectID": "reference/docments.html#attributes",
    "href": "reference/docments.html#attributes",
    "title": "docments",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nempty"
  },
  {
    "objectID": "reference/docments.html#functions",
    "href": "reference/docments.html#functions",
    "title": "docments",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndocments\nGenerates a docment\n\n\ndocstring\nGet docstring for sym for functions ad classes\n\n\nget_dataclass_source\nGet source code for dataclass s\n\n\nget_name\nGet the name of obj\n\n\nget_source\nGet source code for string, function object or dataclass s\n\n\nisdataclass\nCheck if s is a dataclass but not a dataclass’ instance\n\n\nparse_docstring\nParse a numpy-style docstring in sym\n\n\nqual_name\nGet the qualified name of obj\n\n\n\n\n\ndocments.docments(elt, full=False, **kwargs)\nGenerates a docment\n\n\n\ndocments.docstring(sym)\nGet docstring for sym for functions ad classes\n\n\n\ndocments.get_dataclass_source(s)\nGet source code for dataclass s\n\n\n\ndocments.get_name(obj)\nGet the name of obj\n\n\n\ndocments.get_source(s)\nGet source code for string, function object or dataclass s\n\n\n\ndocments.isdataclass(s)\nCheck if s is a dataclass but not a dataclass’ instance\n\n\n\ndocments.parse_docstring(sym)\nParse a numpy-style docstring in sym\n\n\n\ndocments.qual_name(obj)\nGet the qualified name of obj"
  },
  {
    "objectID": "reference/docscrape.html",
    "href": "reference/docscrape.html",
    "title": "docscrape",
    "section": "",
    "text": "docscrape\nParse numpy-style docstrings\n\n\n\n\n\nName\nDescription\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndedent_lines\nDeindent a list of lines maximally\n\n\nstrip_blank_lines\nRemove leading and trailing blank lines from a list of lines\n\n\n\n\n\ndocscrape.dedent_lines(lines, split=True)\nDeindent a list of lines maximally\n\n\n\ndocscrape.strip_blank_lines(l)\nRemove leading and trailing blank lines from a list of lines"
  },
  {
    "objectID": "reference/docscrape.html#attributes",
    "href": "reference/docscrape.html#attributes",
    "title": "docscrape",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nParameter"
  },
  {
    "objectID": "reference/docscrape.html#functions",
    "href": "reference/docscrape.html#functions",
    "title": "docscrape",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndedent_lines\nDeindent a list of lines maximally\n\n\nstrip_blank_lines\nRemove leading and trailing blank lines from a list of lines\n\n\n\n\n\ndocscrape.dedent_lines(lines, split=True)\nDeindent a list of lines maximally\n\n\n\ndocscrape.strip_blank_lines(l)\nRemove leading and trailing blank lines from a list of lines"
  },
  {
    "objectID": "reference/basics.html",
    "href": "reference/basics.html",
    "title": "basics",
    "section": "",
    "text": "basics\n\n\n\n\n\nName\nDescription\n\n\n\n\nSelf\n\n\n\narg0\n\n\n\narg1\n\n\n\narg2\n\n\n\narg3\n\n\n\narg4\n\n\n\ndefaults\n\n\n\ninum_methods\n\n\n\nnum_methods\n\n\n\nrnum_methods\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_props\nCreate properties passing each of range(n) to f\n\n\nanno_ret\nGet the return annotation of func\n\n\nannotations\nAnnotations for o, or type(o)\n\n\nargnames\nNames of arguments to function or frame f\n\n\nargwhere\nLike filter_ex, but return indices for matching items\n\n\nattrdict\nDict from each k in ks to getattr(o,k)\n\n\nbasic_repr\nMinimal __repr__\n\n\ncamel2snake\nConvert CamelCase to snake_case\n\n\ncamel2words\nConvert CamelCase to ‘spaced words’\n\n\nchunked\nReturn batches from iterator it of size chunk_sz (or return n_chunks total)\n\n\nclass2attr\nReturn the snake-cased name of the class; strip ending cls_name if it exists.\n\n\ncompile_re\nCompile pat if it’s not None\n\n\ncompose\nCreate a function that composes all functions in funcs, passing along remaining *args and **kwargs to all\n\n\nconcat\nConcatenate all collections and items as a list\n\n\ncopy_func\nCopy a non-builtin function (NB copy.copy does not work for this)\n\n\ncustom_dir\nImplement custom __dir__, adding add to cls\n\n\ncycle\nLike itertools.cycle except creates list of Nones if o is empty\n\n\ndelegate_attr\nUse in __getattr__ to delegate to attr to without inheriting from GetAttr\n\n\ndetuplify\nIf x is a tuple with one thing, extract it\n\n\neval_type\neval a type or collection of types, if needed, for annotations in py3.10+\n\n\neven_mults\nBuild log-stepped array from start to stop in n steps.\n\n\nexec_import\nImport sym from mod in a new environment\n\n\nexec_local\nCall exec on code and return the var var_name | | [exec_new](#fastcore.basics.exec_new) | Executecodein a new environment and return it | | [filter_dict](#fastcore.basics.filter_dict) | Filter adictusingfunc, applied to keys and values | | [filter_ex](#fastcore.basics.filter_ex) | Likefilter, but passingkwargstof, defaultingftonoop, and addingnegateandgen| | [filter_keys](#fastcore.basics.filter_keys) | Filter adictusingfunc, applied to keys | | [filter_values](#fastcore.basics.filter_values) | Filter adictusingfunc, applied to values | | [first](#fastcore.basics.first) | First element ofx, optionally filtered byf, or None if missing | | [flatten](#fastcore.basics.flatten) | Concatenate all collections and items as a generator | | [gen](#fastcore.basics.gen) | Like(func(o) for o in seq if cond(func(o)))but handlesStopIteration| | [get_annotations_ex](#fastcore.basics.get_annotations_ex) | Backport of py3.10get_annotationsthat returns globals/locals | | [get_class](#fastcore.basics.get_class) | Dynamically create a class, optionally inheriting fromsup, containingfld_names| | [getattrs](#fastcore.basics.getattrs) | List of allattrsino| | [getcallable](#fastcore.basics.getcallable) | Callsgetattrwith a default ofnoop| | [groupby](#fastcore.basics.groupby) | Likeitertools.groupbybut doesn't need to be sorted, and isn't lazy, plus some extensions | | [hasattrs](#fastcore.basics.hasattrs) | Test whetherocontains allattrs| | [ifnone](#fastcore.basics.ifnone) |bifais None elsea| | [in_](#fastcore.basics.in_) |Trueifx in a| | [instantiate](#fastcore.basics.instantiate) | Instantiatetif it's a type, otherwise do nothing | | [is_array](#fastcore.basics.is_array) |Trueifxsupportsarrayoriloc| | [last_index](#fastcore.basics.last_index) | Finds the last index of occurence ofxino(returns -1 if no occurence) | | [listify](#fastcore.basics.listify) | Convertoto alist| | [loop_first](#fastcore.basics.loop_first) | Iterate and generate a tuple with a flag for first value. | | [loop_first_last](#fastcore.basics.loop_first_last) | Iterate and generate a tuple with a flag for first and last value. | | [loop_last](#fastcore.basics.loop_last) | Iterate and generate a tuple with a flag for last value. | | [map_ex](#fastcore.basics.map_ex) | Likemap, but usebind, and supportsstrand indexing | | [maps](#fastcore.basics.maps) | Likemap, except funcs are composed first | | [mapt](#fastcore.basics.mapt) | Tuplifiedmap| | [maybe_attr](#fastcore.basics.maybe_attr) |getattr(o,attr,o)| | [merge](#fastcore.basics.merge) | Merge all dictionaries inds| | [mk_class](#fastcore.basics.mk_class) | Create a class usingget_classand add to the caller's module | | [nested_attr](#fastcore.basics.nested_attr) | Same asgetattr, but ifattrincludes a., then looks inside nested objects | | [nested_callable](#fastcore.basics.nested_callable) | Same asnested_attrbut if not found will returnnoop| | [nested_idx](#fastcore.basics.nested_idx) | Index into nested collections, dicts, etc, withidxs| | [nested_setdefault](#fastcore.basics.nested_setdefault) | Same assetdefault, but ifattrincludes a., then looks inside nested objects | | [not_](#fastcore.basics.not_) | Create new function that negates result off| | [num_cpus](#fastcore.basics.num_cpus) | Get number of cpus | | [only](#fastcore.basics.only) | Return the only item ofo, raise ifodoesn't have exactly one item | | [otherwise](#fastcore.basics.otherwise) |y if tst(x) else x| | [partialler](#fastcore.basics.partialler) | Likefunctools.partialbut also copies over docstring | | [patch](#fastcore.basics.patch) | Decorator: addfto the first parameter's class (based on f's type annotations) | | [patch_property](#fastcore.basics.patch_property) | Deprecated; usepatch(as_prop=True)instead | | [patch_to](#fastcore.basics.patch_to) | Decorator: addftocls| | [properties](#fastcore.basics.properties) | Change attrs inclswith names inpsto properties | | [range_of](#fastcore.basics.range_of) | All indices of collectiona, ifais a collection, otherwiserange| | [renumerate](#fastcore.basics.renumerate) | Same asenumerate, but returns index as 2nd element instead of 1st | | [replicate](#fastcore.basics.replicate) | Create tuple ofitemcopiedlen(match)times | | [ret_false](#fastcore.basics.ret_false) | Predicate: alwaysFalse| | [ret_true](#fastcore.basics.ret_true) | Predicate: alwaysTrue| | [risinstance](#fastcore.basics.risinstance) | Curriedisinstancebut with args reversed | | [set_nested_idx](#fastcore.basics.set_nested_idx) | Set value indexed likenested_idx\n\n\nsetattrs\n\n\n\nsetify\nTurn any list like-object into a set.\n\n\nsignature_ex\nBackport of inspect.signature(..., eval_str=True to &lt;py310\n\n\nsnake2camel\nConvert snake_case to CamelCase\n\n\nsorted_ex\nLike sorted, but if key is str use attrgetter; if int use itemgetter\n\n\nstop\nRaises exception e (by default StopException)\n\n\nstore_attr\nStore params named in comma-separated names from calling context into attrs in self\n\n\nstr2bool\nCase-insensitive convert string s too a bool (y,yes,t,true,on,1-&gt;True)\n\n\nstr_enum\nSimplified creation of StrEnum types\n\n\nstrcat\nConcatenate stringified items its\n\n\ntrue\nTest whether x is truthy; collections with &gt;0 elements are considered True\n\n\ntry_attrs\nReturn first attr that exists in obj\n\n\ntuplify\nMake o a tuple\n\n\ntype_hints\nLike typing.get_type_hints but returns {} if not allowed type\n\n\ntyped\nDecorator to check param and return types at runtime\n\n\nunion2tuple\n\n\n\nuniqueify\nUnique elements in x, optional sort, optional return reverse correspondence, optional prepend with elements.\n\n\nusing_attr\nConstruct a function which applies f to the argument’s attribute attr\n\n\nval2idx\nDict from value to index\n\n\nwith_cast\nDecorator which uses any parameter annotations as preprocessing functions\n\n\nwrap_class\nDecorator: makes function a method of a new class nm passing parameters to mk_class\n\n\nzip_cycle\nLike itertools.zip_longest but cycles through elements of all but first argument\n\n\n\n\n\nbasics.add_props(f, g=None, n=2)\nCreate properties passing each of range(n) to f\n\n\n\nbasics.anno_ret(func)\nGet the return annotation of func\n\n\n\nbasics.annotations(o)\nAnnotations for o, or type(o)\n\n\n\nbasics.argnames(f, frame=False)\nNames of arguments to function or frame f\n\n\n\nbasics.argwhere(iterable, f, negate=False, **kwargs)\nLike filter_ex, but return indices for matching items\n\n\n\nbasics.attrdict(o, *ks, default=None)\nDict from each k in ks to getattr(o,k)\n\n\n\nbasics.basic_repr(flds=None)\nMinimal __repr__\n\n\n\nbasics.camel2snake(name)\nConvert CamelCase to snake_case\n\n\n\nbasics.camel2words(s, space=' ')\nConvert CamelCase to ‘spaced words’\n\n\n\nbasics.chunked(it, chunk_sz=None, drop_last=False, n_chunks=None)\nReturn batches from iterator it of size chunk_sz (or return n_chunks total)\n\n\n\nbasics.class2attr(self, cls_name)\nReturn the snake-cased name of the class; strip ending cls_name if it exists.\n\n\n\nbasics.compile_re(pat)\nCompile pat if it’s not None\n\n\n\nbasics.compose(*funcs, order=None)\nCreate a function that composes all functions in funcs, passing along remaining *args and **kwargs to all\n\n\n\nbasics.concat(colls)\nConcatenate all collections and items as a list\n\n\n\nbasics.copy_func(f)\nCopy a non-builtin function (NB copy.copy does not work for this)\n\n\n\nbasics.custom_dir(c, add)\nImplement custom __dir__, adding add to cls\n\n\n\nbasics.cycle(o)\nLike itertools.cycle except creates list of Nones if o is empty\n\n\n\nbasics.delegate_attr(self, k, to)\nUse in __getattr__ to delegate to attr to without inheriting from GetAttr\n\n\n\nbasics.detuplify(x)\nIf x is a tuple with one thing, extract it\n\n\n\nbasics.eval_type(t, glb, loc)\neval a type or collection of types, if needed, for annotations in py3.10+\n\n\n\nbasics.even_mults(start, stop, n)\nBuild log-stepped array from start to stop in n steps.\n\n\n\nbasics.exec_import(mod, sym)\nImport sym from mod in a new environment\n\n\n\nbasics.exec_local(code, var_name)\nCall exec on code and return the var `var_name\n\n\n\nbasics.exec_new(code)\nExecute code in a new environment and return it\n\n\n\nbasics.filter_dict(d, func)\nFilter a dict using func, applied to keys and values\n\n\n\nbasics.filter_ex(iterable, f=noop, negate=False, gen=False, **kwargs)\nLike filter, but passing kwargs to f, defaulting f to noop, and adding negate and gen\n\n\n\nbasics.filter_keys(d, func)\nFilter a dict using func, applied to keys\n\n\n\nbasics.filter_values(d, func)\nFilter a dict using func, applied to values\n\n\n\nbasics.first(x, f=None, negate=False, **kwargs)\nFirst element of x, optionally filtered by f, or None if missing\n\n\n\nbasics.flatten(o)\nConcatenate all collections and items as a generator\n\n\n\nbasics.gen(func, seq, cond=ret_true)\nLike (func(o) for o in seq if cond(func(o))) but handles StopIteration\n\n\n\nbasics.get_annotations_ex(obj, *, globals=None, locals=None)\nBackport of py3.10 get_annotations that returns globals/locals\n\n\n\nbasics.get_class(nm, *fld_names, sup=None, doc=None, funcs=None, **flds)\nDynamically create a class, optionally inheriting from sup, containing fld_names\n\n\n\nbasics.getattrs(o, *attrs, default=None)\nList of all attrs in o\n\n\n\nbasics.getcallable(o, attr)\nCalls getattr with a default of noop\n\n\n\nbasics.groupby(x, key, val=noop)\nLike itertools.groupby but doesn’t need to be sorted, and isn’t lazy, plus some extensions\n\n\n\nbasics.hasattrs(o, attrs)\nTest whether o contains all attrs\n\n\n\nbasics.ifnone(a, b)\nb if a is None else a\n\n\n\nbasics.in_(x, a)\nTrue if x in a\n\n\n\nbasics.instantiate(t)\nInstantiate t if it’s a type, otherwise do nothing\n\n\n\nbasics.is_array(x)\nTrue if x supports __array__ or iloc\n\n\n\nbasics.last_index(x, o)\nFinds the last index of occurence of x in o (returns -1 if no occurence)\n\n\n\nbasics.listify(o=None, *rest, use_list=False, match=None)\nConvert o to a list\n\n\n\nbasics.loop_first(values)\nIterate and generate a tuple with a flag for first value.\n\n\n\nbasics.loop_first_last(values)\nIterate and generate a tuple with a flag for first and last value.\n\n\n\nbasics.loop_last(values)\nIterate and generate a tuple with a flag for last value.\n\n\n\nbasics.map_ex(iterable, f, *args, gen=False, **kwargs)\nLike map, but use bind, and supports str and indexing\n\n\n\nbasics.maps(*args, retain=noop)\nLike map, except funcs are composed first\n\n\n\nbasics.mapt(func, *iterables)\nTuplified map\n\n\n\nbasics.maybe_attr(o, attr)\ngetattr(o,attr,o)\n\n\n\nbasics.merge(*ds)\nMerge all dictionaries in ds\n\n\n\nbasics.mk_class(nm, *fld_names, sup=None, doc=None, funcs=None, mod=None, **flds)\nCreate a class using get_class and add to the caller’s module\n\n\n\nbasics.nested_attr(o, attr, default=None)\nSame as getattr, but if attr includes a ., then looks inside nested objects\n\n\n\nbasics.nested_callable(o, attr)\nSame as nested_attr but if not found will return noop\n\n\n\nbasics.nested_idx(coll, *idxs)\nIndex into nested collections, dicts, etc, with idxs\n\n\n\nbasics.nested_setdefault(o, attr, default)\nSame as setdefault, but if attr includes a ., then looks inside nested objects\n\n\n\nbasics.not_(f)\nCreate new function that negates result of f\n\n\n\nbasics.num_cpus()\nGet number of cpus\n\n\n\nbasics.only(o)\nReturn the only item of o, raise if o doesn’t have exactly one item\n\n\n\nbasics.otherwise(x, tst, y)\ny if tst(x) else x\n\n\n\nbasics.partialler(f, *args, order=None, **kwargs)\nLike functools.partial but also copies over docstring\n\n\n\nbasics.patch(f=None, *, as_prop=False, cls_method=False)\nDecorator: add f to the first parameter’s class (based on f’s type annotations)\n\n\n\nbasics.patch_property(f)\nDeprecated; use patch(as_prop=True) instead\n\n\n\nbasics.patch_to(cls, as_prop=False, cls_method=False)\nDecorator: add f to cls\n\n\n\nbasics.properties(cls, *ps)\nChange attrs in cls with names in ps to properties\n\n\n\nbasics.range_of(a, b=None, step=None)\nAll indices of collection a, if a is a collection, otherwise range\n\n\n\nbasics.renumerate(iterable, start=0)\nSame as enumerate, but returns index as 2nd element instead of 1st\n\n\n\nbasics.replicate(item, match)\nCreate tuple of item copied len(match) times\n\n\n\nbasics.ret_false(*args, **kwargs)\nPredicate: always False\n\n\n\nbasics.ret_true(*args, **kwargs)\nPredicate: always True\n\n\n\nbasics.risinstance(types, obj=None)\nCurried isinstance but with args reversed\n\n\n\nbasics.set_nested_idx(coll, value, *idxs)\nSet value indexed like `nested_idx\n\n\n\nbasics.setattrs(dest, flds, src)\n\n\n\nbasics.setify(o)\nTurn any list like-object into a set.\n\n\n\nbasics.signature_ex(obj, eval_str=False)\nBackport of inspect.signature(..., eval_str=True to &lt;py310\n\n\n\nbasics.snake2camel(s)\nConvert snake_case to CamelCase\n\n\n\nbasics.sorted_ex(iterable, key=None, reverse=False)\nLike sorted, but if key is str use attrgetter; if int use itemgetter\n\n\n\nbasics.stop(e=StopIteration)\nRaises exception e (by default StopException)\n\n\n\nbasics.store_attr(names=None, self=None, but='', cast=False, store_args=None, **attrs)\nStore params named in comma-separated names from calling context into attrs in self\n\n\n\nbasics.str2bool(s)\nCase-insensitive convert string s too a bool (y,yes,t,true,on,1-&gt;True)\n\n\n\nbasics.str_enum(name, *vals)\nSimplified creation of StrEnum types\n\n\n\nbasics.strcat(its, sep='')\nConcatenate stringified items its\n\n\n\nbasics.true(x)\nTest whether x is truthy; collections with &gt;0 elements are considered True\n\n\n\nbasics.try_attrs(obj, *attrs)\nReturn first attr that exists in obj\n\n\n\nbasics.tuplify(o, use_list=False, match=None)\nMake o a tuple\n\n\n\nbasics.type_hints(f)\nLike typing.get_type_hints but returns {} if not allowed type\n\n\n\nbasics.typed(f)\nDecorator to check param and return types at runtime\n\n\n\nbasics.union2tuple(t)\n\n\n\nbasics.uniqueify(x, sort=False, bidir=False, start=None)\nUnique elements in x, optional sort, optional return reverse correspondence, optional prepend with elements.\n\n\n\nbasics.using_attr(f, attr)\nConstruct a function which applies f to the argument’s attribute attr\n\n\n\nbasics.val2idx(x)\nDict from value to index\n\n\n\nbasics.with_cast(f)\nDecorator which uses any parameter annotations as preprocessing functions\n\n\n\nbasics.wrap_class(nm, *fld_names, sup=None, doc=None, funcs=None, **flds)\nDecorator: makes function a method of a new class nm passing parameters to mk_class\n\n\n\nbasics.zip_cycle(x, *args)\nLike itertools.zip_longest but cycles through elements of all but first argument"
  },
  {
    "objectID": "reference/basics.html#attributes",
    "href": "reference/basics.html#attributes",
    "title": "basics",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nSelf\n\n\n\narg0\n\n\n\narg1\n\n\n\narg2\n\n\n\narg3\n\n\n\narg4\n\n\n\ndefaults\n\n\n\ninum_methods\n\n\n\nnum_methods\n\n\n\nrnum_methods"
  },
  {
    "objectID": "reference/basics.html#functions",
    "href": "reference/basics.html#functions",
    "title": "basics",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadd_props\nCreate properties passing each of range(n) to f\n\n\nanno_ret\nGet the return annotation of func\n\n\nannotations\nAnnotations for o, or type(o)\n\n\nargnames\nNames of arguments to function or frame f\n\n\nargwhere\nLike filter_ex, but return indices for matching items\n\n\nattrdict\nDict from each k in ks to getattr(o,k)\n\n\nbasic_repr\nMinimal __repr__\n\n\ncamel2snake\nConvert CamelCase to snake_case\n\n\ncamel2words\nConvert CamelCase to ‘spaced words’\n\n\nchunked\nReturn batches from iterator it of size chunk_sz (or return n_chunks total)\n\n\nclass2attr\nReturn the snake-cased name of the class; strip ending cls_name if it exists.\n\n\ncompile_re\nCompile pat if it’s not None\n\n\ncompose\nCreate a function that composes all functions in funcs, passing along remaining *args and **kwargs to all\n\n\nconcat\nConcatenate all collections and items as a list\n\n\ncopy_func\nCopy a non-builtin function (NB copy.copy does not work for this)\n\n\ncustom_dir\nImplement custom __dir__, adding add to cls\n\n\ncycle\nLike itertools.cycle except creates list of Nones if o is empty\n\n\ndelegate_attr\nUse in __getattr__ to delegate to attr to without inheriting from GetAttr\n\n\ndetuplify\nIf x is a tuple with one thing, extract it\n\n\neval_type\neval a type or collection of types, if needed, for annotations in py3.10+\n\n\neven_mults\nBuild log-stepped array from start to stop in n steps.\n\n\nexec_import\nImport sym from mod in a new environment\n\n\nexec_local\nCall exec on code and return the var var_name | | [exec_new](#fastcore.basics.exec_new) | Executecodein a new environment and return it | | [filter_dict](#fastcore.basics.filter_dict) | Filter adictusingfunc, applied to keys and values | | [filter_ex](#fastcore.basics.filter_ex) | Likefilter, but passingkwargstof, defaultingftonoop, and addingnegateandgen| | [filter_keys](#fastcore.basics.filter_keys) | Filter adictusingfunc, applied to keys | | [filter_values](#fastcore.basics.filter_values) | Filter adictusingfunc, applied to values | | [first](#fastcore.basics.first) | First element ofx, optionally filtered byf, or None if missing | | [flatten](#fastcore.basics.flatten) | Concatenate all collections and items as a generator | | [gen](#fastcore.basics.gen) | Like(func(o) for o in seq if cond(func(o)))but handlesStopIteration| | [get_annotations_ex](#fastcore.basics.get_annotations_ex) | Backport of py3.10get_annotationsthat returns globals/locals | | [get_class](#fastcore.basics.get_class) | Dynamically create a class, optionally inheriting fromsup, containingfld_names| | [getattrs](#fastcore.basics.getattrs) | List of allattrsino| | [getcallable](#fastcore.basics.getcallable) | Callsgetattrwith a default ofnoop| | [groupby](#fastcore.basics.groupby) | Likeitertools.groupbybut doesn't need to be sorted, and isn't lazy, plus some extensions | | [hasattrs](#fastcore.basics.hasattrs) | Test whetherocontains allattrs| | [ifnone](#fastcore.basics.ifnone) |bifais None elsea| | [in_](#fastcore.basics.in_) |Trueifx in a| | [instantiate](#fastcore.basics.instantiate) | Instantiatetif it's a type, otherwise do nothing | | [is_array](#fastcore.basics.is_array) |Trueifxsupportsarrayoriloc| | [last_index](#fastcore.basics.last_index) | Finds the last index of occurence ofxino(returns -1 if no occurence) | | [listify](#fastcore.basics.listify) | Convertoto alist| | [loop_first](#fastcore.basics.loop_first) | Iterate and generate a tuple with a flag for first value. | | [loop_first_last](#fastcore.basics.loop_first_last) | Iterate and generate a tuple with a flag for first and last value. | | [loop_last](#fastcore.basics.loop_last) | Iterate and generate a tuple with a flag for last value. | | [map_ex](#fastcore.basics.map_ex) | Likemap, but usebind, and supportsstrand indexing | | [maps](#fastcore.basics.maps) | Likemap, except funcs are composed first | | [mapt](#fastcore.basics.mapt) | Tuplifiedmap| | [maybe_attr](#fastcore.basics.maybe_attr) |getattr(o,attr,o)| | [merge](#fastcore.basics.merge) | Merge all dictionaries inds| | [mk_class](#fastcore.basics.mk_class) | Create a class usingget_classand add to the caller's module | | [nested_attr](#fastcore.basics.nested_attr) | Same asgetattr, but ifattrincludes a., then looks inside nested objects | | [nested_callable](#fastcore.basics.nested_callable) | Same asnested_attrbut if not found will returnnoop| | [nested_idx](#fastcore.basics.nested_idx) | Index into nested collections, dicts, etc, withidxs| | [nested_setdefault](#fastcore.basics.nested_setdefault) | Same assetdefault, but ifattrincludes a., then looks inside nested objects | | [not_](#fastcore.basics.not_) | Create new function that negates result off| | [num_cpus](#fastcore.basics.num_cpus) | Get number of cpus | | [only](#fastcore.basics.only) | Return the only item ofo, raise ifodoesn't have exactly one item | | [otherwise](#fastcore.basics.otherwise) |y if tst(x) else x| | [partialler](#fastcore.basics.partialler) | Likefunctools.partialbut also copies over docstring | | [patch](#fastcore.basics.patch) | Decorator: addfto the first parameter's class (based on f's type annotations) | | [patch_property](#fastcore.basics.patch_property) | Deprecated; usepatch(as_prop=True)instead | | [patch_to](#fastcore.basics.patch_to) | Decorator: addftocls| | [properties](#fastcore.basics.properties) | Change attrs inclswith names inpsto properties | | [range_of](#fastcore.basics.range_of) | All indices of collectiona, ifais a collection, otherwiserange| | [renumerate](#fastcore.basics.renumerate) | Same asenumerate, but returns index as 2nd element instead of 1st | | [replicate](#fastcore.basics.replicate) | Create tuple ofitemcopiedlen(match)times | | [ret_false](#fastcore.basics.ret_false) | Predicate: alwaysFalse| | [ret_true](#fastcore.basics.ret_true) | Predicate: alwaysTrue| | [risinstance](#fastcore.basics.risinstance) | Curriedisinstancebut with args reversed | | [set_nested_idx](#fastcore.basics.set_nested_idx) | Set value indexed likenested_idx\n\n\nsetattrs\n\n\n\nsetify\nTurn any list like-object into a set.\n\n\nsignature_ex\nBackport of inspect.signature(..., eval_str=True to &lt;py310\n\n\nsnake2camel\nConvert snake_case to CamelCase\n\n\nsorted_ex\nLike sorted, but if key is str use attrgetter; if int use itemgetter\n\n\nstop\nRaises exception e (by default StopException)\n\n\nstore_attr\nStore params named in comma-separated names from calling context into attrs in self\n\n\nstr2bool\nCase-insensitive convert string s too a bool (y,yes,t,true,on,1-&gt;True)\n\n\nstr_enum\nSimplified creation of StrEnum types\n\n\nstrcat\nConcatenate stringified items its\n\n\ntrue\nTest whether x is truthy; collections with &gt;0 elements are considered True\n\n\ntry_attrs\nReturn first attr that exists in obj\n\n\ntuplify\nMake o a tuple\n\n\ntype_hints\nLike typing.get_type_hints but returns {} if not allowed type\n\n\ntyped\nDecorator to check param and return types at runtime\n\n\nunion2tuple\n\n\n\nuniqueify\nUnique elements in x, optional sort, optional return reverse correspondence, optional prepend with elements.\n\n\nusing_attr\nConstruct a function which applies f to the argument’s attribute attr\n\n\nval2idx\nDict from value to index\n\n\nwith_cast\nDecorator which uses any parameter annotations as preprocessing functions\n\n\nwrap_class\nDecorator: makes function a method of a new class nm passing parameters to mk_class\n\n\nzip_cycle\nLike itertools.zip_longest but cycles through elements of all but first argument\n\n\n\n\n\nbasics.add_props(f, g=None, n=2)\nCreate properties passing each of range(n) to f\n\n\n\nbasics.anno_ret(func)\nGet the return annotation of func\n\n\n\nbasics.annotations(o)\nAnnotations for o, or type(o)\n\n\n\nbasics.argnames(f, frame=False)\nNames of arguments to function or frame f\n\n\n\nbasics.argwhere(iterable, f, negate=False, **kwargs)\nLike filter_ex, but return indices for matching items\n\n\n\nbasics.attrdict(o, *ks, default=None)\nDict from each k in ks to getattr(o,k)\n\n\n\nbasics.basic_repr(flds=None)\nMinimal __repr__\n\n\n\nbasics.camel2snake(name)\nConvert CamelCase to snake_case\n\n\n\nbasics.camel2words(s, space=' ')\nConvert CamelCase to ‘spaced words’\n\n\n\nbasics.chunked(it, chunk_sz=None, drop_last=False, n_chunks=None)\nReturn batches from iterator it of size chunk_sz (or return n_chunks total)\n\n\n\nbasics.class2attr(self, cls_name)\nReturn the snake-cased name of the class; strip ending cls_name if it exists.\n\n\n\nbasics.compile_re(pat)\nCompile pat if it’s not None\n\n\n\nbasics.compose(*funcs, order=None)\nCreate a function that composes all functions in funcs, passing along remaining *args and **kwargs to all\n\n\n\nbasics.concat(colls)\nConcatenate all collections and items as a list\n\n\n\nbasics.copy_func(f)\nCopy a non-builtin function (NB copy.copy does not work for this)\n\n\n\nbasics.custom_dir(c, add)\nImplement custom __dir__, adding add to cls\n\n\n\nbasics.cycle(o)\nLike itertools.cycle except creates list of Nones if o is empty\n\n\n\nbasics.delegate_attr(self, k, to)\nUse in __getattr__ to delegate to attr to without inheriting from GetAttr\n\n\n\nbasics.detuplify(x)\nIf x is a tuple with one thing, extract it\n\n\n\nbasics.eval_type(t, glb, loc)\neval a type or collection of types, if needed, for annotations in py3.10+\n\n\n\nbasics.even_mults(start, stop, n)\nBuild log-stepped array from start to stop in n steps.\n\n\n\nbasics.exec_import(mod, sym)\nImport sym from mod in a new environment\n\n\n\nbasics.exec_local(code, var_name)\nCall exec on code and return the var `var_name\n\n\n\nbasics.exec_new(code)\nExecute code in a new environment and return it\n\n\n\nbasics.filter_dict(d, func)\nFilter a dict using func, applied to keys and values\n\n\n\nbasics.filter_ex(iterable, f=noop, negate=False, gen=False, **kwargs)\nLike filter, but passing kwargs to f, defaulting f to noop, and adding negate and gen\n\n\n\nbasics.filter_keys(d, func)\nFilter a dict using func, applied to keys\n\n\n\nbasics.filter_values(d, func)\nFilter a dict using func, applied to values\n\n\n\nbasics.first(x, f=None, negate=False, **kwargs)\nFirst element of x, optionally filtered by f, or None if missing\n\n\n\nbasics.flatten(o)\nConcatenate all collections and items as a generator\n\n\n\nbasics.gen(func, seq, cond=ret_true)\nLike (func(o) for o in seq if cond(func(o))) but handles StopIteration\n\n\n\nbasics.get_annotations_ex(obj, *, globals=None, locals=None)\nBackport of py3.10 get_annotations that returns globals/locals\n\n\n\nbasics.get_class(nm, *fld_names, sup=None, doc=None, funcs=None, **flds)\nDynamically create a class, optionally inheriting from sup, containing fld_names\n\n\n\nbasics.getattrs(o, *attrs, default=None)\nList of all attrs in o\n\n\n\nbasics.getcallable(o, attr)\nCalls getattr with a default of noop\n\n\n\nbasics.groupby(x, key, val=noop)\nLike itertools.groupby but doesn’t need to be sorted, and isn’t lazy, plus some extensions\n\n\n\nbasics.hasattrs(o, attrs)\nTest whether o contains all attrs\n\n\n\nbasics.ifnone(a, b)\nb if a is None else a\n\n\n\nbasics.in_(x, a)\nTrue if x in a\n\n\n\nbasics.instantiate(t)\nInstantiate t if it’s a type, otherwise do nothing\n\n\n\nbasics.is_array(x)\nTrue if x supports __array__ or iloc\n\n\n\nbasics.last_index(x, o)\nFinds the last index of occurence of x in o (returns -1 if no occurence)\n\n\n\nbasics.listify(o=None, *rest, use_list=False, match=None)\nConvert o to a list\n\n\n\nbasics.loop_first(values)\nIterate and generate a tuple with a flag for first value.\n\n\n\nbasics.loop_first_last(values)\nIterate and generate a tuple with a flag for first and last value.\n\n\n\nbasics.loop_last(values)\nIterate and generate a tuple with a flag for last value.\n\n\n\nbasics.map_ex(iterable, f, *args, gen=False, **kwargs)\nLike map, but use bind, and supports str and indexing\n\n\n\nbasics.maps(*args, retain=noop)\nLike map, except funcs are composed first\n\n\n\nbasics.mapt(func, *iterables)\nTuplified map\n\n\n\nbasics.maybe_attr(o, attr)\ngetattr(o,attr,o)\n\n\n\nbasics.merge(*ds)\nMerge all dictionaries in ds\n\n\n\nbasics.mk_class(nm, *fld_names, sup=None, doc=None, funcs=None, mod=None, **flds)\nCreate a class using get_class and add to the caller’s module\n\n\n\nbasics.nested_attr(o, attr, default=None)\nSame as getattr, but if attr includes a ., then looks inside nested objects\n\n\n\nbasics.nested_callable(o, attr)\nSame as nested_attr but if not found will return noop\n\n\n\nbasics.nested_idx(coll, *idxs)\nIndex into nested collections, dicts, etc, with idxs\n\n\n\nbasics.nested_setdefault(o, attr, default)\nSame as setdefault, but if attr includes a ., then looks inside nested objects\n\n\n\nbasics.not_(f)\nCreate new function that negates result of f\n\n\n\nbasics.num_cpus()\nGet number of cpus\n\n\n\nbasics.only(o)\nReturn the only item of o, raise if o doesn’t have exactly one item\n\n\n\nbasics.otherwise(x, tst, y)\ny if tst(x) else x\n\n\n\nbasics.partialler(f, *args, order=None, **kwargs)\nLike functools.partial but also copies over docstring\n\n\n\nbasics.patch(f=None, *, as_prop=False, cls_method=False)\nDecorator: add f to the first parameter’s class (based on f’s type annotations)\n\n\n\nbasics.patch_property(f)\nDeprecated; use patch(as_prop=True) instead\n\n\n\nbasics.patch_to(cls, as_prop=False, cls_method=False)\nDecorator: add f to cls\n\n\n\nbasics.properties(cls, *ps)\nChange attrs in cls with names in ps to properties\n\n\n\nbasics.range_of(a, b=None, step=None)\nAll indices of collection a, if a is a collection, otherwise range\n\n\n\nbasics.renumerate(iterable, start=0)\nSame as enumerate, but returns index as 2nd element instead of 1st\n\n\n\nbasics.replicate(item, match)\nCreate tuple of item copied len(match) times\n\n\n\nbasics.ret_false(*args, **kwargs)\nPredicate: always False\n\n\n\nbasics.ret_true(*args, **kwargs)\nPredicate: always True\n\n\n\nbasics.risinstance(types, obj=None)\nCurried isinstance but with args reversed\n\n\n\nbasics.set_nested_idx(coll, value, *idxs)\nSet value indexed like `nested_idx\n\n\n\nbasics.setattrs(dest, flds, src)\n\n\n\nbasics.setify(o)\nTurn any list like-object into a set.\n\n\n\nbasics.signature_ex(obj, eval_str=False)\nBackport of inspect.signature(..., eval_str=True to &lt;py310\n\n\n\nbasics.snake2camel(s)\nConvert snake_case to CamelCase\n\n\n\nbasics.sorted_ex(iterable, key=None, reverse=False)\nLike sorted, but if key is str use attrgetter; if int use itemgetter\n\n\n\nbasics.stop(e=StopIteration)\nRaises exception e (by default StopException)\n\n\n\nbasics.store_attr(names=None, self=None, but='', cast=False, store_args=None, **attrs)\nStore params named in comma-separated names from calling context into attrs in self\n\n\n\nbasics.str2bool(s)\nCase-insensitive convert string s too a bool (y,yes,t,true,on,1-&gt;True)\n\n\n\nbasics.str_enum(name, *vals)\nSimplified creation of StrEnum types\n\n\n\nbasics.strcat(its, sep='')\nConcatenate stringified items its\n\n\n\nbasics.true(x)\nTest whether x is truthy; collections with &gt;0 elements are considered True\n\n\n\nbasics.try_attrs(obj, *attrs)\nReturn first attr that exists in obj\n\n\n\nbasics.tuplify(o, use_list=False, match=None)\nMake o a tuple\n\n\n\nbasics.type_hints(f)\nLike typing.get_type_hints but returns {} if not allowed type\n\n\n\nbasics.typed(f)\nDecorator to check param and return types at runtime\n\n\n\nbasics.union2tuple(t)\n\n\n\nbasics.uniqueify(x, sort=False, bidir=False, start=None)\nUnique elements in x, optional sort, optional return reverse correspondence, optional prepend with elements.\n\n\n\nbasics.using_attr(f, attr)\nConstruct a function which applies f to the argument’s attribute attr\n\n\n\nbasics.val2idx(x)\nDict from value to index\n\n\n\nbasics.with_cast(f)\nDecorator which uses any parameter annotations as preprocessing functions\n\n\n\nbasics.wrap_class(nm, *fld_names, sup=None, doc=None, funcs=None, **flds)\nDecorator: makes function a method of a new class nm passing parameters to mk_class\n\n\n\nbasics.zip_cycle(x, *args)\nLike itertools.zip_longest but cycles through elements of all but first argument"
  }
]